//todo make pink line green and sandline red
// keep other 
// alt shift r
// 25% is currently s&p


//@version=5
indicator(title="prop_moneyslope", overlay=false)

XPer = input.int(4, title="X Period 1")
XPer2 = input.int(70, title="X Period 2")
YPer = input.int(1, title="Slope Period")
YPer2 = input.int(1, title="Slope Period 2")
YYPer = input.int(1, title="Slope of Slope Period")
YYPer2 = input.int(1, title="Slope of Slope Period 2")
EMAyn = input.int(1, title="EMA? 1 or 0")

// calculations
X = (EMAyn > 0) ? ta.ema(close, XPer) : ta.sma(close, XPer)
X2 = (EMAyn > 0) ? ta.ema(close, XPer2) : ta.sma(close, XPer2)
YX = (X - X[YPer]) / YPer
YX2 = (X2 - X2[YPer2]) / YPer2
XofYX = ta.sma(YX, 10)
XofYX2 = ta.sma(YX2, 10)
XofXofYX = ta.sma(XofYX, 3)
YXofXofYX = (XofXofYX-XofXofYX[YPer2]) / YPer2
YXofYX = ((XofYX-XofYX[YYPer]) / YYPer) * 10
YXofYX2 = ((XofYX2-XofYX2[YYPer2]) / YYPer2) * 10
XofYXofYX = ta.sma(YXofYX, 10)
XofYXofYX2 = ta.sma(YXofYX2, 10)

// main plot calculations
mainplot = ((XofYX2 * 10) / math.max(math.abs(ta.highest(XofYX2 * 10, 30)), math.abs(ta.lowest(XofYX2 * 10, 30)))) * 10
pperiod = 100
macdplot = (ta.ema(close, 12) - ta.ema(close, 26)) / math.max(math.abs(ta.highest(ta.ema(close, 12) - ta.ema(close, 26), pperiod)), math.abs(ta.lowest(ta.ema(close, 12) - ta.ema(close, 26), pperiod))) * 10
midplot = ((XofXofYX * 4) / math.max(math.abs(ta.highest(XofXofYX * 4, 30)), math.abs(ta.lowest(XofXofYX * 4, 30)))) * 10
minorplot = ((YXofYX2 * 10) / math.max(math.abs(ta.highest(YXofYX2 * 10, 30)), math.abs(ta.lowest(YXofYX2 * 10, 30)))) * 10

// ===== DIVERGENCE DETECTION =====
// Catches when price momentum diverges from indicator momentum (early reversal warning)
lookback = 50
price_high = ta.highest(high, lookback)
price_low = ta.lowest(low, lookback)
mainplot_high = ta.highest(mainplot, lookback)
mainplot_low = ta.lowest(mainplot, lookback)

// Bearish divergence: price at/near highs but mainplot weakening
bearish_divergence = high >= price_high * 0.98 and mainplot < mainplot_high * 0.85
// Bullish divergence: price at/near lows but mainplot strengthening
bullish_divergence = low <= price_low * 1.02 and mainplot > mainplot_low * 1.15

divergence_adjustment = bullish_divergence ? 2.0 : bearish_divergence ? -3.0 : 0.0

// ===== REGIME FILTER =====
// Detects trending vs ranging markets (trend-following signals fail in chop)
// Method: Measure separation between 50 SMA and 200 SMA
sma_50 = ta.sma(close, 50)
sma_200 = ta.sma(close, 200)
sma_separation_pct = math.abs((sma_50 - sma_200) / close) * 100

// Strong trend: SMAs separated by >5% | Ranging: SMAs separated by <2%
is_trending = sma_separation_pct > 5.0
is_ranging = sma_separation_pct < 2.0
regime_multiplier = is_ranging ? 0.6 : 1.0  // 40% penalty in choppy markets

// ===== VOLATILITY FILTER =====
// High volatility = unreliable signals (whipsaws, news spikes, crashes)
atr = ta.atr(14)                           // 14-period Average True Range
atr_avg = ta.sma(atr, 50)                  // 50-period average of ATR
volatility_ratio = atr / atr_avg           // Current volatility vs average

// Normal volatility: <= 2.0x | High volatility: > 2.0x | Extreme: > 3.0x
// Relaxed thresholds to avoid penalizing legitimate strong trending moves
is_high_volatility = volatility_ratio > 2.0
is_extreme_volatility = volatility_ratio > 3.0
volatility_multiplier = is_extreme_volatility ? 0.7 : is_high_volatility ? 0.85 : 1.0

// ===== MULTI-TIMEFRAME CONFIRMATION =====
// Checks if higher timeframe (daily) agrees with current timeframe signals
// Prevents counter-trend trades (e.g., bullish on 1H while daily is bearish)
htf_close = request.security(syminfo.tickerid, "D", close)
htf_ema_50 = request.security(syminfo.tickerid, "D", ta.ema(close, 50))
htf_close_prev = request.security(syminfo.tickerid, "D", close[1])

// HTF is bullish if: price above 50 EMA AND rising
htf_bullish = htf_close > htf_ema_50 and htf_close > htf_close_prev
// HTF is bearish if: price below 50 EMA OR falling
htf_bearish = htf_close < htf_ema_50 or htf_close < htf_close_prev

// Current timeframe bullish if mainplot positive
current_bullish = mainplot > 0

// MTF alignment scoring
mtf_adjustment = current_bullish and htf_bullish ? 1.5 : current_bullish and htf_bearish ? -2.0 : 0.0

// ===== MOMENTUM EXHAUSTION DETECTION =====
// Catches overextended conditions (blow-off tops, capitulation bottoms)
rsi_current = ta.rsi(close, 14)

// Overbought exhaustion: momentum at unsustainable extremes
is_overbought_extreme = mainplot > 8 or rsi_current > 80
is_extremely_overbought = mainplot > 9 and rsi_current > 85

// Oversold capitulation: extreme oversold with bullish reversal signal
is_oversold_capitulation = mainplot < -8 and rsi_current < 20 and current_bullish

// Exhaustion adjustment
exhaustion_adjustment = is_extremely_overbought ? -3.0 : is_overbought_extreme ? -2.0 : is_oversold_capitulation ? 1.0 : 0.0

// ===== MONEY FLOW INDEX (MFI) INTEGRATION =====
// MFI = volume-weighted RSI, measures money flowing in/out
mfi_current = ta.mfi(close, 14)

// MFI scoring: scaled based on money flow strength
// MFI > 50 = money flowing in (bullish) | MFI < 50 = money flowing out (bearish)
mfi_adjustment = current_bullish ? (mfi_current - 50) / 50 * 1.5 : 0.0  // Only apply to bullish signals, scaled -1.5 to +1.5

// ===== RATE OF CHANGE ACCELERATION =====
// Slope is calculated for display/reference only - NOT used in scoring to avoid circular feedback loop
// Removed from score calculation to prevent oscillation and lag issues

// ===== POINTS SYSTEM =====
// Composite momentum scoring system that combines 9 bullish conditions
// Score Range: 0 (bearish) to ~10.63 (maximum bullish)
// Key Thresholds:
//   - 4.0 (line_in_sand_level): Minimum bullish bias
//   - 7.25 (aggressive_level): Strong bullish signal
// Each condition below is weighted by importance and contributes to total_points

// weights (ranked by importance)
line_in_sand_level = 4                    // Minimum bullish threshold
aggressive_level = 7.25                   // Strong bullish threshold
mainplot_weight = 2.13                    // #1 - Short-term momentum strength (scaled 0-2.13)
mainplot_slope_weight = 2.05              // #2 - Mainplot increasing? (binary: 2.05 or 0) - Favors slope to catch trends early
midplot_weight = 0.43                     // #7 - Mid-term momentum strength (scaled 0-0.43)
midplot_slope_weight = 1.58               // #4 - Midplot increasing? (binary: 1.58 or 0) - Favors slope to catch trends early
positive_macd_weight = 1.12               // #5 - MACD increasing? (binary: 1.12 or 0)
minor_over_mid_weight = 0.82              // #6 - Minor > Mid? (binary: 0.82 or 0)
above_50sma_weight = 0.26                 // #9 - Price above 50 SMA (binary: 0.26 or 0)
above_100sma_weight = 0.75                // #8 - Price above 100 SMA (binary: 0.75 or 0) - Mid-term trend
above_200sma_weight = 1.5                 // #3 - Price above 200 SMA (binary: 1.5 or 0) - Long-term trend
mid_above_total_modifier = 1.25           // Multiplier when midplot > EMA(total_points, 30)

// volume conviction multiplier - modulates momentum components based on volume
volume_factor = math.min(math.max(volume / ta.sma(volume, 20), 1.0), 2.0)                                     // Volume relative to 20-SMA, floored at 1.0x, capped at 2.0x (never reduces scores)

// points calculation - BIDIRECTIONAL: awards positive points for bullish, negative for bearish
// Absolute values (mainplot, midplot) scaled from their -10 to +10 range
mainplot_points_raw = math.min(math.max(mainplot / 10 * mainplot_weight, -mainplot_weight), mainplot_weight)  // Bidirectional: -2.13 to +2.13
mainplot_points = mainplot_points_raw * volume_factor                                                          // Apply volume multiplier
midplot_points_raw = math.min(math.max(midplot / 10 * midplot_weight, -midplot_weight), midplot_weight)       // Bidirectional: -0.43 to +0.43
midplot_points = midplot_points_raw * volume_factor                                                            // Apply volume multiplier

// Slope indicators - award positive when rising, negative when falling
mainplot_slope_direction = mainplot - nz(mainplot[1])
mainplot_slope_points_raw = mainplot_slope_direction > 0 ? mainplot_slope_weight : mainplot_slope_direction < 0 ? -mainplot_slope_weight : 0  // Bidirectional: -2.05 to +2.05
mainplot_slope_points = mainplot_slope_points_raw * volume_factor                                              // Apply volume multiplier

midplot_slope_direction = midplot - nz(midplot[1])
midplot_slope_points_raw = midplot_slope_direction > 0 ? midplot_slope_weight : midplot_slope_direction < 0 ? -midplot_slope_weight : 0      // Bidirectional: -1.58 to +1.58
midplot_slope_points = midplot_slope_points_raw * volume_factor                                                // Apply volume multiplier

macd_slope_direction = macdplot - nz(macdplot[1])
macd_slope_points_raw = macd_slope_direction > 0 ? positive_macd_weight : macd_slope_direction < 0 ? -positive_macd_weight : 0               // Bidirectional: -1.12 to +1.12
macd_slope_points = macd_slope_points_raw * volume_factor                                                      // Apply volume multiplier

// Minor vs Mid comparison - bidirectional
minor_vs_mid_points_raw = minorplot > midplot ? minor_over_mid_weight : minorplot < midplot ? -minor_over_mid_weight : 0  // Bidirectional: -0.82 to +0.82
minor_vs_mid_points = minor_vs_mid_points_raw * volume_factor                                                  // Apply volume multiplier

// SMA position - bidirectional (above = positive, below = negative)
above_50sma_points = close > ta.sma(close, 50) ? above_50sma_weight : close < ta.sma(close, 50) ? -above_50sma_weight : 0         // Bidirectional: -0.26 to +0.26
above_100sma_points = close > ta.sma(close, 100) ? above_100sma_weight : close < ta.sma(close, 100) ? -above_100sma_weight : 0    // Bidirectional: -0.75 to +0.75
above_200sma_points = close > ta.sma(close, 200) ? above_200sma_weight : close < ta.sma(close, 200) ? -above_200sma_weight : 0    // Bidirectional: -1.5 to +1.5

// Total composite score - sum of all 9 components (volume modulates 6 of them: all momentum-based)
// Then apply all adjustments and filters
total_points_base = mainplot_points + mainplot_slope_points + midplot_points + midplot_slope_points + macd_slope_points + minor_vs_mid_points + above_50sma_points + above_100sma_points + above_200sma_points
total_points_with_divergence = total_points_base + divergence_adjustment  // Add divergence bonus/penalty (-3 to +2)
total_points_with_mtf = total_points_with_divergence + mtf_adjustment     // Add MTF alignment bonus/penalty (-2 to +1.5)
total_points_with_mfi = total_points_with_mtf + mfi_adjustment            // Add MFI adjustment (-1.5 to +1.5)
total_points_with_exhaustion = total_points_with_mfi + exhaustion_adjustment  // Add exhaustion penalty/bonus (-3 to +1)
total_points_with_regime = total_points_with_exhaustion * regime_multiplier   // Apply regime filter (0.6x in ranging markets)
total_points = total_points_with_regime * volatility_multiplier               // Apply volatility filter (0.7x to 1.0x) - FINAL SCORE

// Calculate slope for display/reference only (NOT used in scoring to avoid circular feedback)
total_points_slope = total_points - nz(total_points[1])                                                                 // Raw slope (change from previous bar)
total_points_slope_normalized = (total_points_slope * 10) / math.max(math.abs(ta.highest(total_points_slope * 10, 30)), math.abs(ta.lowest(total_points_slope * 10, 30))) * 10  // Normalized to -10 to +10 range
total_points_slope_sma = ta.sma(total_points_slope_normalized, 3)                                                       // 3-period SMA smoothing

// ===== DETAILED LOGGING FOR DEBUGGING =====
if barstate.islast or true  // Log on every bar (remove "or true" to log only on last bar)
    log_msg = "=== POINT BREAKDOWN ===\n"

    // Base components (before volume multiplier)
    log_msg := log_msg + "BASE (pre-volume):\n"
    log_msg := log_msg + "  Mainplot: " + str.tostring(mainplot_points_raw, "#.##") + "\n"
    log_msg := log_msg + "  Mainplot slope: " + str.tostring(mainplot_slope_points_raw, "#.##") + "\n"
    log_msg := log_msg + "  Midplot: " + str.tostring(midplot_points_raw, "#.##") + "\n"
    log_msg := log_msg + "  Midplot slope: " + str.tostring(midplot_slope_points_raw, "#.##") + "\n"
    log_msg := log_msg + "  MACD slope: " + str.tostring(macd_slope_points_raw, "#.##") + "\n"
    log_msg := log_msg + "  Minor>Mid: " + str.tostring(minor_vs_mid_points_raw, "#.##") + "\n"
    log_msg := log_msg + "  Above 50 SMA: " + str.tostring(above_50sma_points, "#.##") + "\n"
    log_msg := log_msg + "  Above 100 SMA: " + str.tostring(above_100sma_points, "#.##") + "\n"
    log_msg := log_msg + "  Above 200 SMA: " + str.tostring(above_200sma_points, "#.##") + "\n"

    // Volume multiplier
    log_msg := log_msg + "\nVOLUME MULTIPLIER: " + str.tostring(volume_factor, "#.##") + "x\n"

    // After volume multiplier
    log_msg := log_msg + "\nAFTER VOLUME:\n"
    log_msg := log_msg + "  Mainplot: " + str.tostring(mainplot_points, "#.##") + "\n"
    log_msg := log_msg + "  Mainplot slope: " + str.tostring(mainplot_slope_points, "#.##") + "\n"
    log_msg := log_msg + "  Midplot: " + str.tostring(midplot_points, "#.##") + "\n"
    log_msg := log_msg + "  Midplot slope: " + str.tostring(midplot_slope_points, "#.##") + "\n"
    log_msg := log_msg + "  MACD slope: " + str.tostring(macd_slope_points, "#.##") + "\n"
    log_msg := log_msg + "  Minor>Mid: " + str.tostring(minor_vs_mid_points, "#.##") + "\n"

    // Adjustments
    log_msg := log_msg + "\nADJUSTMENTS:\n"
    log_msg := log_msg + "  Divergence: " + str.tostring(divergence_adjustment, "#.##") + "\n"
    log_msg := log_msg + "  MTF alignment: " + str.tostring(mtf_adjustment, "#.##") + "\n"
    log_msg := log_msg + "  MFI: " + str.tostring(mfi_adjustment, "#.##") + "\n"
    log_msg := log_msg + "  Exhaustion: " + str.tostring(exhaustion_adjustment, "#.##") + "\n"

    // Multipliers
    log_msg := log_msg + "\nMULTIPLIERS:\n"
    log_msg := log_msg + "  Regime: " + str.tostring(regime_multiplier, "#.##") + "x\n"
    log_msg := log_msg + "  Volatility: " + str.tostring(volatility_multiplier, "#.##") + "x\n"

    // Progressive totals
    log_msg := log_msg + "\nPROGRESSIVE TOTALS:\n"
    log_msg := log_msg + "  Base: " + str.tostring(total_points_base, "#.##") + "\n"
    log_msg := log_msg + "  + Divergence: " + str.tostring(total_points_with_divergence, "#.##") + "\n"
    log_msg := log_msg + "  + MTF: " + str.tostring(total_points_with_mtf, "#.##") + "\n"
    log_msg := log_msg + "  + MFI: " + str.tostring(total_points_with_mfi, "#.##") + "\n"
    log_msg := log_msg + "  + Exhaustion: " + str.tostring(total_points_with_exhaustion, "#.##") + "\n"
    log_msg := log_msg + "  * Regime: " + str.tostring(total_points_with_regime, "#.##") + "\n"
    log_msg := log_msg + "  * Volatility (FINAL): " + str.tostring(total_points, "#.##") + "\n"

    log.info(log_msg)

// Score ranges with all modifiers (NOW BIDIRECTIONAL):
// Baseline bullish (all positive, 1x volume, no adjustments): +10.64 max
// Extreme bullish (all positive, 2x volume, all positive adjustments): ~+25 max
// Neutral (mixed signals, no clear trend): ~0
// Baseline bearish (all negative, 1x volume, no adjustments): -10.64 min
// Extreme bearish (all negative, 2x volume, all negative adjustments): ~-25 min

// Boost modifier - increases total_points by 25% when midplot exceeds its 30-period EMA trend
mid_above_total = midplot > ta.ema(total_points, 30) ? total_points * mid_above_total_modifier : total_points

/// plotting
plot(0, color=color.new(#BA68C8, 0), linewidth=1)
plot(line_in_sand_level, color=#ff101066, linewidth=1)
//plot(mainplot, color=color.rgb(119, 179, 207, 23), linewidth=2)
plot(aggressive_level, color=color.new(#c585f1, 50), linewidth=2)
//plot(macdplot, color=color.blue)
//plot(midplot, color=color.new(#39665e, 60), linewidth=2)
//plot(minorplot, color=color.new(#434651, 0), linewidth=1)
//plot(total_points, color=color.new(#c0e5e2, 20), linewidth=2)
//plot(ta.sma(total_points, 10), color=color.new(#babe80, 0), linewidth=2)
plot(ta.ema(total_points, 30), color=#85f18a, linewidth=2)
//plot(total_points_slope_sma, color=color.new(#ff9800, 0), linewidth=2, title="Total Points Slope (SMA 3)")
//experiment with sma values then create bottom indicator off of mid_above_total < 9
//plot(ta.sma(mid_above_total, 5), color=#acab9962, linewidth=1)










//START OVERBOUGHT TECH
autoTip = "(100, 0) = Auto Calculate Levels"

tf = input.timeframe("", "Calculations Time Frame                                ")
ticker = input.symbol("", "Ticker ID")
src = input.source(close, "Source", inline = "calc")
len = input.int(14, "                    Length", 1, inline = "calc")
hybColor = input.color(color.black, "Hybrid Overbought/Oversold Graph →", inline = "hyb")
hideHyb = input.bool(true, "Hide", inline = "hyb")
obManual = input.int(100, "Alert Levels → OB:", inline = "alert")
osManual = input.int(0, "OS:", tooltip = autoTip, inline = "alert")
alertFreq = input.string("Bar Level", "Alerts", ["Bar Level", "Touches Level", "Bar Passed"])
showSignal = input.bool(true, "Background Color Signals →", inline = "signal")
callColor = input.color(color.teal, "Call:", inline = "signal")
putColor = input.color(color.maroon, "Put:", inline = "signal")
weakSignal = input.bool(true, "Color Weaker Signals        →", inline = "weakSignal")
callWeakColor = input.color(color.green, "Call:", inline = "weakSignal")
putWeakColor = input.color(color.red, "Put:", inline = "weakSignal")
drawOBS = input.bool(true, "Draw OB/OS Levels      ", inline = "levels")
showOBSLabels = input.bool(true, "Show Level Labels", tooltip = "In order to make this option work for individual oscillators, 'Hide' option for each of the following technicals should be unchecked.", inline = "levels")

techGroup = "=====[ Technicals to Apply in Hybrid Calculations ]====="
useB = input.bool(true, "Bollinger Bands %B", inline = "bUse", group = techGroup)
bColor = input.color(color.gray, "                            →", inline = "bUse", group = techGroup)
hideB = input.bool(true, "Hide", inline = "bUse", group = techGroup)
bOBManual = input.int(100, "      Levels → OB:", inline = "bLevels", group = techGroup)
bOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "bLevels", group = techGroup)
useCci = input.bool(true, "Commodity Channel Index (CCI)", inline = "cciUse", group = techGroup)
cciColor = input.color(color.aqua, "       →", inline = "cciUse", group = techGroup)
hideCci = input.bool(true, "Hide", inline = "cciUse", group = techGroup)
cciOBManual = input.int(100, "      Levels → OB:", inline = "cciLevels", group = techGroup)
cciOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "cciLevels", group = techGroup)
useCmf = input.bool(true, "Chaikin Money Flow (CMF)", inline = "cmfUse", group = techGroup)
cmfColor = input.color(color.blue, "               →", inline = "cmfUse", group = techGroup)
hideCmf = input.bool(true, "Hide", inline = "cmfUse", group = techGroup)
cmfOBManual = input.int(100, "      Levels → OB:", inline = "cmfLevels", group = techGroup)
cmfOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "cmfLevels", group = techGroup)
useCmo = input.bool(true, "Chande Momentum Oscillator (CMO)", inline = "cmoUse", group = techGroup)
cmoColor = input.color(color.navy, "→", inline = "cmoUse", group = techGroup)
hideCmo = input.bool(true, "Hide", inline = "cmoUse", group = techGroup)
cmoOBManual = input.int(100, "      Levels → OB:", inline = "cmoLevels", group = techGroup)
cmoOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "cmoLevels", group = techGroup)
useDix = input.bool(true, "Disparity Index (DIX)", inline = "dixUse", group = techGroup)
dixColor = input.color(color.teal, "                        →", inline = "dixUse", group = techGroup)
hideDix = input.bool(true, "Hide", inline = "dixUse", group = techGroup)
dixOBManual = input.int(100, "      Levels → OB:", inline = "dixLevels", group = techGroup)
dixOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "dixLevels", group = techGroup)
useK = input.bool(true, "Keltner Channel %K", inline = "kUse", group = techGroup)
kColor = input.color(color.green, "                          →", inline = "kUse", group = techGroup)
hideK = input.bool(true, "Hide", inline = "kUse", group = techGroup)
kOBManual = input.int(100, "      Levels → OB:", inline = "kLevels", group = techGroup)
kOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "kLevels", group = techGroup)
useMfi = input.bool(true, "Money Flow Index (MFI)", inline = "mfiUse", group = techGroup)
mfiColor = input.color(color.olive, "                   →", inline = "mfiUse", group = techGroup)
hideMfi = input.bool(true, "Hide", inline = "mfiUse", group = techGroup)
mfiOBManual = input.int(100, "      Levels → OB:", inline = "mfiLevels", group = techGroup)
mfiOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "mfiLevels", group = techGroup)
useRoc = input.bool(true, "Rate Of Change (ROC / Momentum)", inline = "rocUse", group = techGroup)
rocColor = input.color(color.purple, " →", inline = "rocUse", group = techGroup)
hideRoc = input.bool(true, "Hide", inline = "rocUse", group = techGroup)
rocOBManual = input.int(100, "      Levels → OB:", inline = "rocLevels", group = techGroup)
rocOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "rocLevels", group = techGroup)
useRsi = input.bool(true, "Relative Strength Index (RSI)", inline = "rsiUse", group = techGroup)
rsiColor = input.color(color.fuchsia, "           →", inline = "rsiUse", group = techGroup)
hideRsi = input.bool(true, "Hide", inline = "rsiUse", group = techGroup)
rsiOBManual = input.int(100, "      Levels → OB:", inline = "rsiLevels", group = techGroup)
rsiOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "rsiLevels", group = techGroup)
useRvi = input.bool(true, "Relative Vigor Index (RVI / RVGI)", inline = "rviUse", group = techGroup)
rviColor = input.color(color.maroon, "     →", inline = "rviUse", group = techGroup)
hideRvi = input.bool(true, "Hide", inline = "rviUse", group = techGroup)
rviOBManual = input.int(100, "      Levels → OB:", inline = "rviLevels", group = techGroup)
rviOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "rviLevels", group = techGroup)
useSto = input.bool(true, "Stochastic (William's %R)", inline = "stoUse", group = techGroup)
stoColor = input.color(color.red, "                  →", inline = "stoUse", group = techGroup)
hideSto = input.bool(true, "Hide", inline = "stoUse", group = techGroup)
stoOBManual = input.int(100, "      Levels → OB:", inline = "stoLevels", group = techGroup)
stoOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "stoLevels", group = techGroup)
useTmf = input.bool(true, "Twiggs Money Flow (TMF)", inline = "tmfUse", group = techGroup)
tmfColor = input.color(color.orange, "                →", inline = "tmfUse", group = techGroup)
hideTmf = input.bool(true, "Hide", inline = "tmfUse", group = techGroup)
tmfOBManual = input.int(100, "      Levels → OB:", inline = "tmfLevels", group = techGroup)
tmfOSManual = input.int(0, "OS:", tooltip = autoTip, inline = "tmfLevels", group = techGroup)

alertFrequency = alertFreq == "Every Time A Bar Touches An OB/OS Level" ? alert.freq_all : alertFreq == "When A Bar Closes While Passed An OB/OS Level" ? alert.freq_once_per_bar_close : alert.freq_once_per_bar
maxArraySize = 100000
oscCount = 0

var bOBSum = array.new_int(), var bOSSum = array.new_int()
var cciOBSum = array.new_int(), var cciOSSum = array.new_int()
var cmfOBSum = array.new_int(), var cmfOSSum = array.new_int()
var cmoOBSum = array.new_int(), var cmoOSSum = array.new_int()
var dixOBSum = array.new_int(), var dixOSSum = array.new_int()
var kOBSum = array.new_int(), var kOSSum = array.new_int()
var mfiOBSum = array.new_int(), var mfiOSSum = array.new_int()
var rocOBSum = array.new_int(), var rocOSSum = array.new_int()
var rsiOBSum = array.new_int(), var rsiOSSum = array.new_int()
var rviOBSum = array.new_int(), var rviOSSum = array.new_int()
var stoOBSum = array.new_int(), var stoOSSum = array.new_int()
var tmfOBSum = array.new_int(), var tmfOSSum = array.new_int()
if bOBSum.size() == maxArraySize
    bOBSum.shift()
if cciOBSum.size() == maxArraySize
    cciOBSum.shift()
if cmfOBSum.size() == maxArraySize
    cmfOBSum.shift()
if cmoOBSum.size() == maxArraySize
    cmoOBSum.shift()
if dixOBSum.size() == maxArraySize
    dixOBSum.shift()
if kOBSum.size() == maxArraySize
    kOBSum.shift()
if mfiOBSum.size() == maxArraySize
    mfiOBSum.shift()
if rocOBSum.size() == maxArraySize
    rocOBSum.shift()
if rsiOBSum.size() == maxArraySize
    rsiOBSum.shift()
if rviOBSum.size() == maxArraySize
    rviOBSum.shift()
if stoOBSum.size() == maxArraySize
    stoOBSum.shift()
if tmfOBSum.size() == maxArraySize
    tmfOBSum.shift()
if bOSSum.size() == maxArraySize
    bOSSum.shift()
if cciOSSum.size() == maxArraySize
    cciOSSum.shift()
if cmfOSSum.size() == maxArraySize
    cmfOSSum.shift()
if cmoOSSum.size() == maxArraySize
    cmoOSSum.shift()
if dixOSSum.size() == maxArraySize
    dixOSSum.shift()
if kOSSum.size() == maxArraySize
    kOSSum.shift()
if mfiOSSum.size() == maxArraySize
    mfiOSSum.shift()
if rocOSSum.size() == maxArraySize
    rocOSSum.shift()
if rsiOSSum.size() == maxArraySize
    rsiOSSum.shift()
if rviOSSum.size() == maxArraySize
    rviOSSum.shift()
if stoOSSum.size() == maxArraySize
    stoOSSum.shift()
if tmfOSSum.size() == maxArraySize
    tmfOSSum.shift()

var hybOBSum = array.new_int()
var hybOSSum = array.new_int()
if hybOBSum.size() == maxArraySize
    hybOBSum.shift()
if hybOSSum.size() == maxArraySize
    hybOSSum.shift()

[bar, o, c] = request.security(ticker, tf, [bar_index, open, close])

//}
// functions {

showAlert(message, price, t, freq) =>
    alert(message + "\n" + ticker + "\n" + str.format_time(t, "MM-dd, HH:mm", "Asia/Tehran") + "\n@ " + str.tostring(price), freq)

drawHLine(y, c) =>
    line.new(bar_index[1], y, bar_index, y, extend = extend.both, style = line.style_dotted, color = c)

normal(s, min, max) =>
    var hMin = 1e11
    var hMax = -1e11
    hMin := math.min(nz(s, hMin), hMin)
    hMax := math.max(nz(s, hMax), hMax)
    min + (max - min) * (s - hMin) / math.max(hMax - hMin, 0)

graphs(src, len) =>
    b = normal((src - ta.sma(src, len) + ta.stdev(src, len)) / (2 * ta.stdev(src, len)), 0, 100)
    cci = normal(ta.cci(src, len), 0, 100)
    cmf = normal(math.sum((high == low) ? 0 : volume * (2 * src - low - high) / (high - low), len) / math.sum(volume, len), 0, 100)
    cmo = (ta.cmo(src, len) + 100) / 2
    dix = normal((((src - ta.sma(src, len)) / ta.sma(src, len) * 100) + 1) * 50, 0, 100)
    k = normal((src - (ta.ema(src, len) - ta.atr(len))) / (2 * ta.atr(len)), 0, 100)
    mfi = ta.mfi(src, len)
    roc = normal(ta.roc(src, len), 0, 100)
    rsi = ta.rsi(src, len)
    rvi = ((math.sum(ta.swma(close - open), len) / math.sum(ta.swma(high - low), len)) + 1) * 50
    sto = ta.stoch(src, high, low, len)
    tmf = normal(ta.ema((((src - math.min(low, src[1])) - (math.max(high, src[1]) - src)) / (math.max(high, src[1]) - math.min(low, src[1]))) * volume, len) / ta.ema(volume, len), 0, 100)
    [b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf]

levels(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf) =>
    if bar != bar[1] and c < o and c[1] > o[1] and
     (na(b) ? true : b[1] > 50) and
     (na(cci) ? true : cci[1] > 50) and
     (na(cmf) ? true : cmf[1] > 50) and
     (na(cmo) ? true : cmo[1] > 50) and
     (na(dix) ? true : dix[1] > 50) and
     (na(k) ? true : k[1] > 50) and
     (na(mfi) ? true : mfi[1] > 50) and
     (na(roc) ? true : roc[1] > 50) and
     (na(rsi) ? true : rsi[1] > 50) and
     (na(rvi) ? true : rvi[1] > 50) and
     (na(sto) ? true : sto[1] > 50) and
     (na(tmf) ? true : tmf[1] > 50)
        bOBSum.push(math.ceil(b[1]))
        cciOBSum.push(math.ceil(cci[1]))
        cmfOBSum.push(math.ceil(cmf[1]))
        cmoOBSum.push(math.ceil(cmo[1]))
        dixOBSum.push(math.ceil(dix[1]))
        kOBSum.push(math.ceil(k[1]))
        mfiOBSum.push(math.ceil(mfi[1]))
        rocOBSum.push(math.ceil(roc[1]))
        rsiOBSum.push(math.ceil(rsi[1]))
        rviOBSum.push(math.ceil(rvi[1]))
        stoOBSum.push(math.ceil(sto[1]))
        tmfOBSum.push(math.ceil(tmf[1]))
    if bar != bar[1] and c > o and c[1] < o[1] and
     (na(b) ? true : b[1] < 50) and
     (na(cci) ? true : cci[1] < 50) and
     (na(cmf) ? true : cmf[1] < 50) and
     (na(cmo) ? true : cmo[1] < 50) and
     (na(dix) ? true : dix[1] < 50) and
     (na(k) ? true : k[1] < 50) and
     (na(mfi) ? true : mfi[1] < 50) and
     (na(roc) ? true : roc[1] < 50) and
     (na(rsi) ? true : rsi[1] < 50) and
     (na(rvi) ? true : rvi[1] < 50) and
     (na(sto) ? true : sto[1] < 50) and
     (na(tmf) ? true : tmf[1] < 50)
        bOSSum.push(math.floor(b[1]))
        cciOSSum.push(math.floor(cci[1]))
        cmfOSSum.push(math.floor(cmf[1]))
        cmoOSSum.push(math.floor(cmo[1]))
        dixOSSum.push(math.floor(dix[1]))
        kOSSum.push(math.floor(k[1]))
        mfiOSSum.push(math.floor(mfi[1]))
        rocOSSum.push(math.floor(roc[1]))
        rsiOSSum.push(math.floor(rsi[1]))
        rviOSSum.push(math.floor(rvi[1]))
        stoOSSum.push(math.floor(sto[1]))
        tmfOSSum.push(math.floor(tmf[1]))
    bOB = math.ceil(bOBSum.avg()), bOS = math.floor(bOSSum.avg())
    cciOB = math.ceil(cciOBSum.avg()), cciOS = math.floor(cciOSSum.avg())
    cmfOB = math.ceil(cmfOBSum.avg()), cmfOS = math.floor(cmfOSSum.avg())
    cmoOB = math.ceil(cmoOBSum.avg()), cmoOS = math.floor(cmoOSSum.avg())
    dixOB = math.ceil(dixOBSum.avg()), dixOS = math.floor(dixOSSum.avg())
    kOB = math.ceil(kOBSum.avg()), kOS = math.floor(kOSSum.avg())
    mfiOB = math.ceil(mfiOBSum.avg()), mfiOS = math.floor(mfiOSSum.avg())
    rocOB = math.ceil(rocOBSum.avg()), rocOS = math.floor(rocOSSum.avg())
    rsiOB = math.ceil(rsiOBSum.avg()), rsiOS = math.floor(rsiOSSum.avg())
    rviOB = math.ceil(rviOBSum.avg()), rviOS = math.floor(rviOSSum.avg())
    stoOB = math.ceil(stoOBSum.avg()), stoOS = math.floor(stoOSSum.avg())
    tmfOB = math.ceil(tmfOBSum.avg()), tmfOS = math.floor(tmfOSSum.avg())
    [bOB, bOS, cciOB, cciOS, cmfOB, cmfOS, cmoOB, cmoOS, dixOB, dixOS, kOB, kOS, mfiOB, mfiOS, rocOB, rocOS, rsiOB, rsiOS, rviOB, rviOS, stoOB, stoOS, tmfOB, tmfOS]

hybLevels(hyb) =>
    if bar != bar[1] and c < o and c[1] > o[1] and hyb[1] > 50
        hybOBSum.push(math.ceil(hyb[1]))
    if bar != bar[1] and c > o and c[1] < o[1] and hyb[1] < 50
        hybOSSum.push(math.floor(hyb[1]))
    [math.ceil(array.avg(hybOBSum)), math.floor(array.avg(hybOSSum))]

ob(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf, bOB, cciOB, cmfOB, cmoOB, dixOB, kOB, mfiOB, rocOB, rsiOB, rviOB, stoOB, tmfOB) =>
    percent = 100.
    bit = 100 / oscCount
    if useB and b <= bOB
        percent -= bit
    if useCci and cci <= cciOB
        percent -= bit
    if useCmf and cmf <= cmfOB
        percent -= bit
    if useCmo and cmo <= cmoOB
        percent -= bit
    if useDix and dix <= dixOB
        percent -= bit
    if useK and k <= kOB
        percent -= bit
    if useMfi and mfi <= mfiOB
        percent -= bit
    if useRoc and roc <= rocOB
        percent -= bit
    if useRsi and rsi <= rsiOB
        percent -= bit
    if useRvi and rvi <= rviOB
        percent -= bit
    if useSto and sto <= stoOB
        percent -= bit
    if useTmf and tmf <= tmfOB
        percent -= bit
    percent

os(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf, bOS, cciOS, cmfOS, cmoOS, dixOS, kOS, mfiOS, rocOS, rsiOS, rviOS, stoOS, tmfOS) =>
    percent = 100.
    bit = 100 / oscCount
    if useB and b >= bOS
        percent -= bit
    if useCci and cci >= cciOS
        percent -= bit
    if useCmf and cmf >= cmfOS
        percent -= bit
    if useCmo and cmo >= cmoOS
        percent -= bit
    if useDix and dix >= dixOS
        percent -= bit
    if useK and k >= kOS
        percent -= bit
    if useMfi and mfi >= mfiOS
        percent -= bit
    if useRoc and roc >= rocOS
        percent -= bit
    if useRsi and rsi >= rsiOS
        percent -= bit
    if useRvi and rvi >= rviOS
        percent -= bit
    if useSto and sto >= stoOS
        percent -= bit
    if useTmf and tmf >= tmfOS
        percent -= bit
    percent

//}
// calculate oscillators, ob/os levels & hybrid graph {

[b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf] = request.security(ticker, tf, graphs(src, len))

if useB and not na(b)
    oscCount += 1
if useCci and not na(cci)
    oscCount += 1
if useCmf and not na(cmf)
    oscCount += 1
if useCmo and not na(cmo)
    oscCount += 1
if useDix and not na(dix)
    oscCount += 1
if useK and not na(k)
    oscCount += 1
if useMfi and not na(mfi)
    oscCount += 1
if useRoc and not na(roc)
    oscCount += 1
if useRsi and not na(rsi)
    oscCount += 1
if useRvi and not na(rvi)
    oscCount += 1
if useSto and not na(sto)
    oscCount += 1
if useTmf and not na(tmf)
    oscCount += 1

[bOBAuto, bOSAuto, cciOBAuto, cciOSAuto, cmfOBAuto, cmfOSAuto, cmoOBAuto, cmoOSAuto, dixOBAuto, dixOSAuto, kOBAuto, kOSAuto, mfiOBAuto, mfiOSAuto, rocOBAuto, rocOSAuto, rsiOBAuto, rsiOSAuto, rviOBAuto, rviOSAuto, stoOBAuto, stoOSAuto, tmfOBAuto, tmfOSAuto] =
 levels(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf)

bOB = bOBManual == 100 ? bOBAuto : bOBManual
bOS = bOSManual == 0 ? bOSAuto : bOSManual
cciOB = cciOBManual == 100 ? cciOBAuto : cciOBManual
cciOS = cciOSManual == 0 ? cciOSAuto : cciOSManual
cmfOB = cmfOBManual == 100 ? cmfOBAuto : cmfOBManual
cmfOS = cmfOSManual == 0 ? cmfOSAuto : cmfOSManual
cmoOB = cmoOBManual == 100 ? cmoOBAuto : cmoOBManual
cmoOS = cmoOSManual == 0 ? cmoOSAuto : cmoOSManual
dixOB = dixOBManual == 100 ? dixOBAuto : dixOBManual
dixOS = dixOSManual == 0 ? dixOSAuto : dixOSManual
kOB = kOBManual == 100 ? kOBAuto : kOBManual
kOS = kOSManual == 0 ? kOSAuto : kOSManual
mfiOB = mfiOBManual == 100 ? mfiOBAuto : mfiOBManual
mfiOS = mfiOSManual == 0 ? mfiOSAuto : mfiOSManual
rocOB = rocOBManual == 100 ? rocOBAuto : rocOBManual
rocOS = rocOSManual == 0 ? rocOSAuto : rocOSManual
rsiOB = rsiOBManual == 100 ? rsiOBAuto : rsiOBManual
rsiOS = rsiOSManual == 0 ? rsiOSAuto : rsiOSManual
rviOB = rviOBManual == 100 ? rviOBAuto : rviOBManual
rviOS = rviOSManual == 0 ? rviOSAuto : rviOSManual
stoOB = stoOBManual == 100 ? stoOBAuto : stoOBManual
stoOS = stoOSManual == 0 ? stoOSAuto : stoOSManual
tmfOB = tmfOBManual == 100 ? tmfOBAuto : tmfOBManual
tmfOS = tmfOSManual == 0 ? tmfOSAuto : tmfOSManual

hybrid = (ob(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf, bOB, cciOB, cmfOB, cmoOB, dixOB, kOB, mfiOB, rocOB, rsiOB, rviOB, stoOB, tmfOB) - os(b, cci, cmf, cmo, dix, k, mfi, roc, rsi, rvi, sto, tmf, bOS, cciOS, cmfOS, cmoOS, dixOS, kOS, mfiOS, rocOS, rsiOS, rviOS, stoOS, tmfOS) + 100) / 2
[hybOBAuto, hybOSAuto] = hybLevels(hybrid)
hybOB = obManual == 100 ? hybOBAuto : obManual
hybOS = osManual == 0 ? hybOSAuto : osManual

//}
// show oscillators ob/os labels {

if showOBSLabels
    if not hideHyb
        hybObL = label.new(bar_index + 15, hybOB, str.tostring(hybOB), color = color.new(putWeakColor, 70), style = label.style_label_left, tooltip = "Hybrid OB Level")
        hybOsL = label.new(bar_index + 15, hybOS, str.tostring(hybOS), color = color.new(callWeakColor, 70), style = label.style_label_left, tooltip = "Hybrid OS Level")
        label.delete(hybObL[1])
        label.delete(hybOsL[1])
    y = 100 - (50 / oscCount)
    if useB and not hideB and not na(b)
        bL = label.new(bar_index + 2, y, str.tostring(bOB) + " ; " + str.tostring(bOS), color = bColor, style = label.style_label_left, textcolor = color.white, tooltip = "%B OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(bL[1])
    if useCci and not hideCci and not na(cci)
        cciL = label.new(bar_index + 2, y, str.tostring(cciOB) + " ; " + str.tostring(cciOS), color = cciColor, style = label.style_label_left, textcolor = color.white, tooltip = "CCI OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(cciL[1])
    if useCmf and not hideCmf and not na(cmf)
        cmfL = label.new(bar_index + 2, y, str.tostring(cmfOB) + " ; " + str.tostring(cmfOS), color = cmfColor, style = label.style_label_left, textcolor = color.white, tooltip = "CMF OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(cmfL[1])
    if useCmo and not hideCmo and not na(cmo)
        cmoL = label.new(bar_index + 2, y, str.tostring(cmoOB) + " ; " + str.tostring(cmoOS), color = cmoColor, style = label.style_label_left, textcolor = color.white, tooltip = "CMO OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(cmoL[1])
    if useDix and not hideDix and not na(dix)
        dixL = label.new(bar_index + 2, y, str.tostring(dixOB) + " ; " + str.tostring(dixOS), color = dixColor, style = label.style_label_left, textcolor = color.white, tooltip = "DIX OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(dixL[1])
    if useK and not hideK and not na(k)
        kL = label.new(bar_index + 2, y, str.tostring(kOB) + " ; " + str.tostring(kOS), color = kColor, style = label.style_label_left, textcolor = color.white, tooltip = "%K OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(kL[1])
    if useMfi and not hideMfi and not na(mfi)
        mfiL = label.new(bar_index + 2, y, str.tostring(mfiOB) + " ; " + str.tostring(mfiOS), color = mfiColor, style = label.style_label_left, textcolor = color.white, tooltip = "MFI OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(mfiL[1])
    if useRoc and not hideRoc and not na(roc)
        rocL = label.new(bar_index + 2, y, str.tostring(rocOB) + " ; " + str.tostring(rocOS), color = rocColor, style = label.style_label_left, textcolor = color.white, tooltip = "ROC OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(rocL[1])
    if useRsi and not hideRsi and not na(rsi)
        rsiL = label.new(bar_index + 2, y, str.tostring(rsiOB) + " ; " + str.tostring(rsiOS), color = rsiColor, style = label.style_label_left, textcolor = color.white, tooltip = "RSI OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(rsiL[1])
    if useRvi and not hideRvi and not na(rvi)
        rviL = label.new(bar_index + 2, y, str.tostring(rviOB) + " ; " + str.tostring(rviOS), color = rviColor, style = label.style_label_left, textcolor = color.white, tooltip = "RVI OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(rviL[1])
    if useSto and not hideSto and not na(sto)
        stoL = label.new(bar_index + 2, y, str.tostring(stoOB) + " ; " + str.tostring(stoOS), color = stoColor, style = label.style_label_left, textcolor = color.white, tooltip = "%R OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(stoL[1])
    if useTmf and not hideTmf and not na(tmf)
        tmfL = label.new(bar_index + 2, y, str.tostring(tmfOB) + " ; " + str.tostring(tmfOS), color = tmfColor, style = label.style_label_left, textcolor = color.white, tooltip = "TMF OB & OS Levels")
        y := y - (100 / oscCount)
        label.delete(tmfL[1])

//}
// show oscillators & ob/os levels {

plot(hideB ? na : b, color = bColor)
plot(hideCci ? na : cci, color = cciColor)
plot(hideCmf ? na : cmf, color = cmfColor)
plot(hideCmo ? na : cmo, color = cmoColor)
plot(hideDix ? na : dix, color = dixColor)
plot(hideK ? na : k, color = kColor)
plot(hideMfi ? na : mfi, color = mfiColor)
plot(hideRoc ? na : roc, color = rocColor)
plot(hideRsi ? na : rsi, color = rsiColor)
plot(hideRvi ? na : rvi, color = rviColor)
plot(hideSto ? na : sto, color = stoColor)
plot(hideTmf ? na : tmf, color = tmfColor)
plot(hideHyb ? na : hybrid, "Hybrid", linewidth = 2, color = hybColor)
if drawOBS
    if not hideB
        drawHLine(bOB, bColor)
        drawHLine(bOS, bColor)
    if not hideCci
        drawHLine(cciOB, cciColor)
        drawHLine(cciOS, cciColor)
    if not hideCmf
        drawHLine(cmfOB, cmfColor)
        drawHLine(cmfOS, cmfColor)
    if not hideCmo
        drawHLine(cmoOB, cmoColor)
        drawHLine(cmoOS, cmoColor)
    if not hideDix
        drawHLine(dixOB, dixColor)
        drawHLine(dixOS, dixColor)
    if not hideK
        drawHLine(kOB, kColor)
        drawHLine(kOS, kColor)
    if not hideMfi
        drawHLine(mfiOB, mfiColor)
        drawHLine(mfiOS, mfiColor)
    if not hideRoc
        drawHLine(rocOB, rocColor)
        drawHLine(rocOS, rocColor)
    if not hideRsi
        drawHLine(rsiOB, rsiColor)
        drawHLine(rsiOS, rsiColor)
    if not hideRvi
        drawHLine(rviOB, rviColor)
        drawHLine(rviOS, rviColor)
    if not hideSto
        drawHLine(stoOB, stoColor)
        drawHLine(stoOS, stoColor)
    if not hideTmf
        drawHLine(tmfOB, tmfColor)
        drawHLine(tmfOS, tmfColor)
    drawHLine(0, hybColor)
    drawHLine(50, hybColor)
    drawHLine(100, hybColor)
    if not hideHyb
        drawHLine(hybOB, putWeakColor)
        drawHLine(hybOS, callWeakColor)

//}
// signals & alerts {

bgcolor(weakSignal and hybrid < 50 and hybrid > 0 ? color.new(callWeakColor, 92) : na)
bgcolor(weakSignal and hybrid < 50 / math.phi and hybrid > 0 ? color.new(callWeakColor, 88) : na)
bgcolor(weakSignal and hybrid < 50 / math.phi / math.phi and hybrid > 0 ? color.new(callWeakColor, 81) : na)
bgcolor(weakSignal and hybrid < 50 / math.phi / math.phi / math.phi and hybrid > 0 ? color.new(callWeakColor, 69) : na)
bgcolor(weakSignal and hybrid < 50 / math.phi / math.phi / math.phi / math.phi and hybrid > 0 ? callWeakColor : na)
//bgcolor(showSignal and hybrid == 0 ? callColor : na)
//bgcolor(weakSignal and hybrid > 50 and hybrid < 100 ? color.new(putWeakColor, 85) : na)
//bgcolor(weakSignal and hybrid > 100 - (50 / math.phi) and hybrid < 100 ? color.new(putWeakColor, 76) : na)
//bgcolor(weakSignal and hybrid > 100 - (50 / math.phi / math.phi) and hybrid < 100 ? color.new(putWeakColor, 62) : na)
//bgcolor(weakSignal and hybrid > 100 - (50 / math.phi / math.phi / math.phi) and hybrid < 100 ? color.new(putWeakColor, 38) : na)
//bgcolor(weakSignal and hybrid > 100 - (50 / math.phi / math.phi / math.phi / math.phi) and hybrid < 100 ? putWeakColor : na)
//bgcolor(showSignal and hybrid == 100 ? putColor : na)

up = hybrid <= hybOS
down = hybrid >= hybOB
if up or down
    showAlert(up ? "Buy ↑" : "Sell ↓", close, time, alertFrequency)

//}